)]}'
{"version":3,"sources":["accounts-base/accounts_common.js","accounts-base/url_client.js","accounts-base/accounts_client.js","accounts-base/localstorage_token.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sB;AACA,2D;AACA,G;AACA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;;AAEA,G;AACA,wC;AACA,kB;AACA,0B;AACA,6H;AACA,kP;AACA,4jB;AACA,0M;AACA,8R;AACA,G;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,8D;AACA,oE;AACA,yC;AACA,yC;AACA,wB;AACA,uF;AACA,sC;AACA,2F;AACA,gF;AACA,gD;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,sB;AACA,uE;AACA,+D;AACA,uE;AACA,I;AACA,sE;AACA,4D;AACA,6B;AACA,0C;;AAEA,yD;AACA,0D;AACA,uE;AACA,+D;AACA,kE;AACA,gE;AACA,M;AACA,mE;AACA,4D;AACA,sC;AACA,wD;AACA,G;AACA,C;;AAEA,uE;AACA,kE;AACA,qD;;AAEA,G;AACA,yE;AACA,kB;AACA,2B;AACA,G;AACA,8C;AACA,4B;AACA,uE;AACA,G;AACA,gE;AACA,c;;AAEA,uF;AACA,4B;AACA,4B;AACA,0D;AACA,2E;AACA,0D;AACA,G;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACzLA,oD;AACA,wB;;AAEA,oE;AACA,yE;;AAEA,8C;AACA,mD;AACA,4C;AACA,c;;AAEA,8D;AACA,mC;;AAEA,gB;AACA,uB;;AAEA,8B;AACA,yC;AACA,6C;AACA,8C;AACA,2C;AACA,gD;AACA,6C;AACA,O;AACA,Y;AACA,a;AACA,K;;AAEA,8C;AACA,4B;AACA,K;AACA,E;;AAEA,uC;AACA,2B;;AAEA,qE;AACA,mC;AACA,8B;AACA,E;;AAEA,4E;AACA,8B;AACA,oE;AACA,yE;AACA,2B;;AAEA,kB;AACA,4B;;AAEA,kD;AACA,8B;AACA,wE;AACA,qC;AACA,yD;AACA,K;AACA,K;AACA,G;;AAEA,qB;AACA,gB;AACA,wC;AACA,E;;AAEA,uE;AACA,sE;AACA,uD;;AAEA,G;AACA,6E;AACA,sB;AACA,yE;AACA,+D;AACA,sB;AACA,+E;AACA,E;AACA,2D;AACA,uD;AACA,wF;AACA,wE;AACA,iE;AACA,gB;AACA,G;AACA,oD;AACA,4C;AACA,8E;AACA,mD;AACA,G;;AAEA,iD;AACA,E;;AAEA,G;AACA,0E;AACA,8B;AACA,uE;AACA,+D;AACA,sB;AACA,+E;AACA,E;AACA,gE;AACA,mD;AACA,iF;AACA,0E;AACA,2E;AACA,mB;AACA,gB;AACA,G;AACA,wD;AACA,0C;AACA,kF;AACA,mD;AACA,G;;AAEA,+C;AACA,E;;AAEA,G;AACA,0E;AACA,8B;AACA,mE;AACA,+D;AACA,sB;AACA,+E;AACA,E;AACA,2D;AACA,wE;AACA,+B;AACA,yE;AACA,+E;AACA,uD;AACA,gB;AACA,G;AACA,iD;AACA,4C;AACA,2E;AACA,mD;AACA,G;;AAEA,iD;AACA,E;;;;;;;;;;;;;;;;;;;AC7IA,G;AACA,gB;AACA,G;;AAEA,oB;;AAEA,G;AACA,+F;AACA,wC;AACA,G;AACA,6B;AACA,sC;AACA,E;;AAEA,sB;AACA,2C;AACA,4E;AACA,4E;AACA,mB;AACA,uC;AACA,wB;AACA,kB;AACA,4B;AACA,G;AACA,E;;AAEA,G;AACA,+K;AACA,gB;AACA,G;AACA,gC;AACA,yB;AACA,mB;AACA,E;;AAEA,wC;;AAEA,G;AACA,mG;AACA,wC;AACA,G;AACA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,iB;AACA,G;;AAEA,qC;AACA,E;AACA,6E;AACA,4E;AACA,0E;AACA,6B;AACA,E;AACA,+B;AACA,2D;AACA,wC;AACA,0D;AACA,0D;AACA,2D;AACA,uB;AACA,E;AACA,W;AACA,qD;AACA,kD;AACA,uE;AACA,8E;AACA,6D;AACA,0E;AACA,yD;AACA,E;AACA,+C;AACA,sB;AACA,wB;AACA,0B;AACA,6B;AACA,c;AACA,yE;AACA,gC;AACA,2D;AACA,oB;AACA,kC;AACA,K;AACA,qD;AACA,sD;;AAEA,0B;;AAEA,6E;AACA,2E;AACA,0E;AACA,wE;AACA,2E;AACA,yE;AACA,yE;AACA,0C;AACA,I;AACA,0E;AACA,4E;AACA,4E;AACA,2E;AACA,gE;AACA,iD;AACA,0C;AACA,6C;AACA,Y;AACA,qD;AACA,2B;AACA,mE;AACA,6C;AACA,0B;AACA,oB;AACA,+B;AACA,mD;AACA,Y;AACA,S;AACA,kC;AACA,sE;AACA,8D;AACA,gC;AACA,gB;AACA,oC;AACA,sD;AACA,wE;AACA,+E;AACA,mD;AACA,qC;AACA,4C;AACA,sD;AACA,0B;AACA,8E;AACA,2E;AACA,6E;AACA,6E;AACA,+E;AACA,gF;AACA,6E;AACA,8E;AACA,6E;AACA,gF;AACA,gF;AACA,kB;AACA,8E;AACA,gF;AACA,0E;AACA,6E;AACA,0E;AACA,wE;AACA,wC;AACA,iB;AACA,e;AACA,8E;AACA,+E;AACA,wB;AACA,sC;AACA,gB;AACA,S;AACA,Q;AACA,K;AACA,I;;AAEA,qE;AACA,6E;AACA,U;AACA,+D;AACA,wE;AACA,2E;AACA,2E;AACA,yD;AACA,0E;AACA,oB;AACA,a;;AAEA,yE;AACA,gE;AACA,iD;AACA,kC;AACA,2B;AACA,iC;AACA,wD;AACA,8B;AACA,a;AACA,K;AACA,S;AACA,qC;AACA,iB;AACA,0B;AACA,a;AACA,K;;AAEA,2E;AACA,qE;AACA,uB;AACA,I;;AAEA,kC;AACA,iC;AACA,4B;AACA,uB;AACA,4B;AACA,qD;AACA,kC;AACA,E;;AAEA,kC;AACA,sB;AACA,sC;AACA,yC;AACA,E;;AAEA,4D;AACA,+C;AACA,wC;AACA,E;;AAEA,G;AACA,6B;AACA,gB;AACA,qI;AACA,G;AACA,qC;AACA,iF;AACA,gB;AACA,kC;AACA,Y;AACA,4B;AACA,6B;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,0H;AACA,gB;AACA,qI;AACA,G;AACA,iD;AACA,wE;AACA,wE;AACA,kE;AACA,sE;AACA,uE;AACA,uE;AACA,+D;AACA,qE;AACA,+B;AACA,I;AACA,sE;AACA,qE;AACA,6D;AACA,uE;AACA,wE;AACA,2B;AACA,4B;AACA,kB;AACA,O;AACA,mB;AACA,4B;AACA,kB;AACA,4E;AACA,O;AACA,K;AACA,I;AACA,4B;AACA,wB;AACA,O;AACA,mB;AACA,oB;AACA,gC;AACA,K;AACA,I;AACA,E;;;AAGA,G;AACA,kB;AACA,G;;AAEA,yB;AACA,oE;;AAEA,sE;AACA,sE;AACA,6C;AACA,E;AACA,gD;AACA,qC;AACA,E;;AAEA,oE;AACA,4D;AACA,gE;AACA,kE;AACA,8D;AACA,6D;AACA,sE;AACA,uB;;AAEA,gC;AACA,oC;;AAEA,kE;AACA,qE;AACA,oE;AACA,oE;AACA,E;AACA,yC;AACA,+B;AACA,gC;AACA,M;AACA,mC;AACA,E;;;AAGA,qE;AACA,8D;AACA,iD;AACA,E;AACA,kD;AACA,iC;AACA,gF;AACA,W;AACA,G;AACA,iF;AACA,8B;AACA,yC;AACA,E;;;AAGA,G;AACA,sB;AACA,G;;AAEA,yE;AACA,kB;AACA,oB;AACA,K;AACA,Y;AACA,uB;AACA,mB;AACA,oH;AACA,K;AACA,0E;AACA,yB;AACA,K;;AAEA,K;AACA,Y;AACA,qB;AACA,mB;AACA,4D;AACA,K;AACA,wE;AACA,8B;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACxWA,gE;AACA,oE;AACA,uE;AACA,W;;AAEA,6B;;AAEA,qE;AACA,Q;AACA,oD;AACA,4B;AACA,uC;AACA,6B;AACA,E;;AAEA,sE;AACA,iC;AACA,yC;AACA,0B;AACA,yB;AACA,E;;;AAGA,G;AACA,W;AACA,G;;AAEA,mC;AACA,wC;AACA,sD;AACA,gC;;AAEA,uE;AACA,sE;AACA,kE;AACA,kD;AACA,8C;AACA,sC;AACA,E;;AAEA,yD;AACA,kD;AACA,qD;AACA,qB;AACA,yD;AACA,mE;;AAEA,oE;AACA,0B;AACA,mC;AACA,E;;AAEA,gC;AACA,6C;AACA,iD;AACA,wD;;AAEA,oE;AACA,0B;AACA,kC;AACA,E;;AAEA,sE;AACA,6B;AACA,E;AACA,4D;AACA,qD;AACA,E;;AAEA,uC;AACA,4D;AACA,E;;AAEA,+B;AACA,iD;AACA,E;;AAEA,kD;AACA,wE;AACA,yE;AACA,wB;AACA,E;;AAEA,G;AACA,c;AACA,G;;AAEA,uB;AACA,iE;AACA,iE;AACA,mC;AACA,iC;AACA,c;AACA,mE;AACA,kE;AACA,gC;AACA,oD;AACA,iD;AACA,gB;AACA,6D;AACA,8B;AACA,O;AACA,+B;AACA,uB;AACA,sB;AACA,mB;AACA,4B;AACA,8D;AACA,mE;AACA,qB;AACA,0C;AACA,S;AACA,O;AACA,G;AACA,C;;AAEA,sE;AACA,c;AACA,iC;AACA,uC;AACA,yB;AACA,W;;AAEA,6C;;AAEA,gF;AACA,sD;AACA,4B;AACA,+D;AACA,gB;AACA,gC;AACA,S;AACA,Y;AACA,sB;AACA,K;AACA,G;AACA,+C;AACA,E;;AAEA,wC","file":"/packages/accounts-base.js","sourcesContent":["/**\n * @namespace Accounts\n * @summary The namespace for all accounts-related methods.\n */\nAccounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// how long (in days) until a login token expires\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\n// Clients don't try to auto-login with a token that is going to expire within\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\n// Tries to avoid abrupt disconnects from expiring tokens.\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\n// how often (in milliseconds) we check for expired tokens\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\n// called\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n// - restrictCreationByEmailDomain {Function or String}\n//     Require created users to have an email matching the function or\n//     having the string as domain.\n// - loginExpirationInDays {Number}\n//     Number of days since login until a user is logged out (login token\n//     expires).\n\n/**\n * @summary Set global accounts options.\n * @locus Anywhere\n * @param {Object} options\n * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\n * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \"Create account\" link will not be available.\n * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\n * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\n * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specifed on the server.  See packages/oauth-encryption/README.md for details.\n */\nAccounts.config = function(options) {\n  // We don't want users to accidentally only call Accounts.config on the\n  // client, where some of the options will have partial effects (eg removing\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\n  // is set, or redirecting Google login to a specific-domain page) without\n  // having their full effects.\n  if (Meteor.isServer) {\n    __meteor_runtime_config__.accountsConfigCalled = true;\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\n    // message, but there's no trivial way to do this.\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\n                  \"server; some configuration options may not take effect.\");\n  }\n\n  // We need to validate the oauthSecretKey option at the time\n  // Accounts.config is called. We also deliberately don't store the\n  // oauthSecretKey in Accounts._options.\n  if (_.has(options, \"oauthSecretKey\")) {\n    if (Meteor.isClient)\n      throw new Error(\"The oauthSecretKey option may only be specified on the server\");\n    if (! Package[\"oauth-encryption\"])\n      throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\n    Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\n    options = _.omit(options, \"oauthSecretKey\");\n  }\n\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n\n  // If the user set loginExpirationInDays to null, then we need to clear the\n  // timer that periodically expires tokens.\n  if (Meteor.isServer)\n    maybeStopExpireTokensInterval();\n};\n\nif (Meteor.isClient) {\n  // The connection used by the Accounts system. This is the connection\n  // that will get logged in by Meteor.login(), and this is the\n  // connection whose login state will be reflected by Meteor.userId().\n  //\n  // It would be much preferable for this to be in accounts_client.js,\n  // but it has to be here because it's needed to create the\n  // Meteor.users collection.\n  Accounts.connection = Meteor.connection;\n\n  if (typeof __meteor_runtime_config__ !== \"undefined\" &&\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\n    // Temporary, internal hook to allow the server to point the client\n    // to a different authentication server. This is for a very\n    // particular use case that comes up when implementing a oauth\n    // server. Unsupported and may go away at any point in time.\n    //\n    // We will eventually provide a general way to use account-base\n    // against any DDP connection, not just one special one.\n    Accounts.connection = DDP.connect(\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL)\n  }\n}\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n\n/**\n * @summary A [Mongo.Collection](#collections) containing user documents.\n * @locus Anywhere\n * @type {Mongo.Collection}\n */\nMeteor.users = new Mongo.Collection(\"users\", {\n  _preventAutopublish: true,\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nMeteor.startup(function () {\n  var ServiceConfiguration =\n    Package['service-configuration'].ServiceConfiguration;\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\n});\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\ngetTokenLifetimeMs = function () {\n  return (Accounts._options.loginExpirationInDays ||\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n};\n\nAccounts._tokenExpiration = function (when) {\n  // We pass when through the Date constructor for backwards compatibility;\n  // `when` used to be a number.\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\n};\n\nAccounts._tokenExpiresSoon = function (when) {\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\n  if (minLifetimeMs > minLifetimeCapMs)\n    minLifetimeMs = minLifetimeCapMs;\n  return new Date() > (new Date(when) - minLifetimeMs);\n};\n","// By default, allow the autologin process to happen\nautoLoginEnabled = true;\n\n// All of the special hash URLs we support for accounts interactions\nvar accountsPaths = [\"reset-password\", \"verify-email\", \"enroll-account\"];\n\n// Separate out this functionality for testing\nvar attemptToMatchHash = function (hash, success) {\n  _.each(accountsPaths, function (urlPart) {\n    var token;\n\n    tokenRegex = new RegExp(\"^\\\\#\\\\/\" + urlPart + \"\\\\/(.*)$\");\n    match = hash.match(tokenRegex);\n\n    if (match) {\n      token = match[1];\n\n      // XXX COMPAT WITH 0.9.3\n      if (urlPart === \"reset-password\") {\n        Accounts._resetPasswordToken = token;\n      } else if (urlPart === \"verify-email\") {\n        Accounts._verifyEmailToken = token;\n      } else if (urlPart === \"enroll-account\") {\n        Accounts._enrollAccountToken = token;\n      }\n    } else {\n      return;\n    }\n\n    // Do some stuff with the token we matched\n    success(token, urlPart);\n  });\n};\n\n// We only support one callback per URL\nvar accountsCallbacks = {};\n\n// The UI flow will call this when done to log in the existing person\nvar enableAutoLogin = function () {\n  Accounts._enableAutoLogin();\n};\n\n// Actually call the function, has to happen in the top level so that we can\n// mess with autoLoginEnabled.\nattemptToMatchHash(window.location.hash, function (token, urlPart) {\n  // put login in a suspended state to wait for the interaction to finish\n  autoLoginEnabled = false;\n\n  // reset the URL\n  window.location.hash = \"\";\n\n  // wait for other packages to register callbacks\n  Meteor.startup(function () {\n    // if a callback has been registered for this kind of token, call it\n    if (accountsCallbacks[urlPart]) {\n      accountsCallbacks[urlPart](token, enableAutoLogin);\n    }\n  });\n});\n\n// Export for testing\nAccountsTest = {\n  attemptToMatchHash: attemptToMatchHash\n};\n\n// XXX these should be moved to accounts-password eventually. Right now\n// this is prevented by the need to set autoLoginEnabled=false, but in\n// some bright future we won't need to do that anymore.\n\n/**\n * @summary Register a function to call when a reset password link is clicked\n * in an email sent by\n * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword).\n * 2. `done`: A function to call when the password reset UI flow is complete. The normal\n * login process is suspended until this function is called, so that the\n * password for user A can be reset even if user B was logged in.\n * @locus Client\n */\nAccounts.onResetPasswordLink = function (callback) {\n  if (accountsCallbacks[\"reset-password\"]) {\n    Meteor._debug(\"Accounts.onResetPasswordLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  accountsCallbacks[\"reset-password\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an email verification link is\n * clicked in an email sent by\n * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: An email verification token that can be passed to\n * [`Accounts.verifyEmail`](#accounts_verifyemail).\n * 2. `done`: A function to call when the email verification UI flow is complete.\n * The normal login process is suspended until this function is called, so\n * that the user can be notified that they are verifying their email before\n * being logged in.\n * @locus Client\n */\nAccounts.onEmailVerificationLink = function (callback) {\n  if (accountsCallbacks[\"verify-email\"]) {\n    Meteor._debug(\"Accounts.onEmailVerificationLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  accountsCallbacks[\"verify-email\"] = callback;\n};\n\n/**\n * @summary Register a function to call when an account enrollment link is\n * clicked in an email sent by\n * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n * This function should be called in top-level code, not inside\n * `Meteor.startup()`.\n * @param  {Function} callback The function to call. It is given two arguments:\n *\n * 1. `token`: A password reset token that can be passed to\n * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\n * enrolled account a password.\n * 2. `done`: A function to call when the enrollment UI flow is complete.\n * The normal login process is suspended until this function is called, so that\n * user A can be enrolled even if user B was logged in.\n * @locus Client\n */\nAccounts.onEnrollmentLink = function (callback) {\n  if (accountsCallbacks[\"enroll-account\"]) {\n    Meteor._debug(\"Accounts.onEnrollmentLink was called more than once. \" +\n      \"Only one callback added will be executed.\");\n  }\n\n  accountsCallbacks[\"enroll-account\"] = callback;\n};\n","///\n/// CURRENT USER\n///\n\n// This is reactive.\n\n/**\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\n * @locus Anywhere but publish functions\n */\nMeteor.userId = function () {\n  return Accounts.connection.userId();\n};\n\nvar loggingIn = false;\nvar loggingInDeps = new Tracker.Dependency;\n// This is mostly just called within this file, but Meteor.loginWithPassword\n// also uses it to make loggingIn() be true during the beginPasswordExchange\n// method call too.\nAccounts._setLoggingIn = function (x) {\n  if (loggingIn !== x) {\n    loggingIn = x;\n    loggingInDeps.changed();\n  }\n};\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n */\nMeteor.loggingIn = function () {\n  loggingInDeps.depend();\n  return loggingIn;\n};\n\n// This calls userId, which is reactive.\n\n/**\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\n * @locus Anywhere but publish functions\n */\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAccounts.callLoginMethod = function (options) {\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n  // make sure we only call the user's callback once.\n  var onceUserCallback = _.once(options.userCallback);\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      Accounts.connection.onReconnect = null;\n    } else {\n      Accounts.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = Accounts._tokenExpiration(new Date());\n        if (Accounts._tokenExpiresSoon(result.tokenExpires)) {\n          makeClientLoggedOut();\n        } else {\n          Accounts.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              onceUserCallback(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    Accounts._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      onceUserCallback(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      onceUserCallback(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    onceUserCallback();\n  };\n\n  if (!options._suppressLoggingIn)\n    Accounts._setLoggingIn(true);\n  Accounts.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nmakeClientLoggedOut = function() {\n  unstoreLoginToken();\n  Accounts.connection.setUserId(null);\n  Accounts.connection.onReconnect = null;\n};\n\nmakeClientLoggedIn = function(userId, token, tokenExpires) {\n  storeLoginToken(userId, token, tokenExpires);\n  Accounts.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logout = function (callback) {\n  Accounts.connection.apply('logout', [], {wait: true}, function(error, result) {\n    if (error) {\n      callback && callback(error);\n    } else {\n      makeClientLoggedOut();\n      callback && callback();\n    }\n  });\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logoutOtherClients = function (callback) {\n  // We need to make two method calls: one to replace our current token,\n  // and another to remove all tokens except the current one. We want to\n  // call these two methods one after the other, without any other\n  // methods running between them. For example, we don't want `logout`\n  // to be called in between our two method calls (otherwise the second\n  // method call would return an error). Another example: we don't want\n  // logout to be called before the callback for `getNewToken`;\n  // otherwise we would momentarily log the user out and then write a\n  // new token to localStorage.\n  //\n  // To accomplish this, we make both calls as wait methods, and queue\n  // them one after the other, without spinning off the event loop in\n  // between. Even though we queue `removeOtherTokens` before\n  // `getNewToken`, we won't actually send the `removeOtherTokens` call\n  // until the `getNewToken` callback has finished running, because they\n  // are both wait methods.\n  Accounts.connection.apply(\n    'getNewToken',\n    [],\n    { wait: true },\n    function (err, result) {\n      if (! err) {\n        storeLoginToken(Meteor.userId(), result.token, result.tokenExpires);\n      }\n    }\n  );\n  Accounts.connection.apply(\n    'removeOtherTokens',\n    [],\n    { wait: true },\n    function (err) {\n      callback && callback(err);\n    }\n  );\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\nvar loginServicesHandle =\n  Accounts.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAccounts.loginServicesConfigured = function () {\n  return loginServicesHandle.ready();\n};\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\nvar pageLoadLoginCallbacks = [];\nvar pageLoadLoginAttemptInfo = null;\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAccounts.onPageLoadLogin = function (f) {\n  if (pageLoadLoginAttemptInfo)\n    f(pageLoadLoginAttemptInfo);\n  else\n    pageLoadLoginCallbacks.push(f);\n};\n\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAccounts._pageLoadLogin = function (attemptInfo) {\n  if (pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n  _.each(pageLoadLoginCallbacks, function (callback) { callback(attemptInfo); });\n  pageLoadLoginCallbacks = [];\n  pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n","// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\nvar lastLoginTokenWhenPolled;\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  Accounts.callLoginMethod({\n    methodArguments: [{resume: token}],\n    userCallback: callback});\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAccounts._enableAutoLogin = function () {\n  autoLoginEnabled = true;\n  pollStoredLoginToken();\n};\n\n\n///\n/// STORING\n///\n\n// Key names to use in localStorage\nvar loginTokenKey = \"Meteor.loginToken\";\nvar loginTokenExpiresKey = \"Meteor.loginTokenExpires\";\nvar userIdKey = \"Meteor.userId\";\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAccounts._isolateLoginTokenForTest = function () {\n  loginTokenKey = loginTokenKey + Random.id();\n  userIdKey = userIdKey + Random.id();\n};\n\nstoreLoginToken = function(userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(userIdKey, userId);\n  Meteor._localStorage.setItem(loginTokenKey, token);\n  if (! tokenExpires)\n    tokenExpires = Accounts._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(loginTokenExpiresKey, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = token;\n};\n\nunstoreLoginToken = function() {\n  Meteor._localStorage.removeItem(userIdKey);\n  Meteor._localStorage.removeItem(loginTokenKey);\n  Meteor._localStorage.removeItem(loginTokenExpiresKey);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nstoredLoginToken = Accounts._storedLoginToken = function() {\n  return Meteor._localStorage.getItem(loginTokenKey);\n};\n\nstoredLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(loginTokenExpiresKey);\n};\n\nvar storedUserId = function() {\n  return Meteor._localStorage.getItem(userIdKey);\n};\n\nvar unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = Meteor._localStorage.getItem(loginTokenExpiresKey);\n  if (tokenExpires && Accounts._tokenExpiresSoon(new Date(tokenExpires)))\n    unstoreLoginToken();\n};\n\n///\n/// AUTO-LOGIN\n///\n\nif (autoLoginEnabled) {\n  // Immediately try to log in via local storage, so that any DDP\n  // messages are sent after we have established our user account\n  unstoreLoginTokenIfExpiresSoon();\n  var token = storedLoginToken();\n  if (token) {\n    // On startup, optimistically present us as logged in while the\n    // request is in flight. This reduces page flicker on startup.\n    var userId = storedUserId();\n    userId && Accounts.connection.setUserId(userId);\n    Meteor.loginWithToken(token, function (err) {\n      if (err) {\n        Meteor._debug(\"Error logging in with token: \" + err);\n        makeClientLoggedOut();\n      }\n      Accounts._pageLoadLogin({\n        type: \"resume\",\n        allowed: !err,\n        error: err,\n        methodName: \"login\",\n        // XXX This is duplicate code with loginWithToken, but\n        // loginWithToken can also be called at other times besides\n        // page load.\n        methodArguments: [{resume: token}]\n      });\n    });\n  }\n}\n\n// Poll local storage every 3 seconds to login if someone logged in in\n// another tab\nlastLoginTokenWhenPolled = token;\nvar pollStoredLoginToken = function() {\n  if (! autoLoginEnabled)\n    return;\n\n  var currentLoginToken = storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      Meteor.loginWithToken(currentLoginToken, function (err) {\n        if (err)\n          makeClientLoggedOut();\n      });\n    } else {\n      Meteor.logout();\n    }\n  }\n  lastLoginTokenWhenPolled = currentLoginToken;\n};\n\nsetInterval(pollStoredLoginToken, 3000);\n"]}