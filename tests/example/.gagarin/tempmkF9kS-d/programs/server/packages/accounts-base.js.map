{"version":3,"sources":["accounts-base/accounts_common.js","accounts-base/accounts_server.js","accounts-base/url_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sB;AACA,2D;AACA,G;AACA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;;AAEA,G;AACA,wC;AACA,kB;AACA,0B;AACA,6H;AACA,kP;AACA,4jB;AACA,0M;AACA,8R;AACA,G;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,8D;AACA,oE;AACA,yC;AACA,yC;AACA,wB;AACA,uF;AACA,sC;AACA,2F;AACA,gF;AACA,gD;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,sB;AACA,uE;AACA,+D;AACA,uE;AACA,I;AACA,sE;AACA,4D;AACA,6B;AACA,0C;;AAEA,yD;AACA,0D;AACA,uE;AACA,+D;AACA,kE;AACA,gE;AACA,M;AACA,mE;AACA,4D;AACA,sC;AACA,wD;AACA,G;AACA,C;;AAEA,uE;AACA,kE;AACA,qD;;AAEA,G;AACA,yE;AACA,kB;AACA,2B;AACA,G;AACA,8C;AACA,4B;AACA,uE;AACA,G;AACA,gE;AACA,c;;AAEA,uF;AACA,4B;AACA,4B;AACA,0D;AACA,2E;AACA,0D;AACA,G;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACzLA,mC;;AAEA,G;AACA,gB;AACA,G;;AAEA,6B;AACA,sE;AACA,kE;AACA,oE;AACA,gE;AACA,kE;AACA,mE;AACA,kE;AACA,mE;AACA,oB;AACA,uD;AACA,yB;AACA,gH;AACA,kC;AACA,E;;AAEA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;;AAGA,G;AACA,e;AACA,G;;AAEA,2D;AACA,mC;;AAEA,kE;AACA,4B;AACA,0C;AACA,G;AACA,mC;AACA,iD;AACA,G;;AAEA,G;AACA,oC;AACA,gB;AACA,gL;AACA,G;AACA,iD;AACA,0C;AACA,E;;AAEA,G;AACA,4E;AACA,gB;AACA,6E;AACA,G;AACA,oC;AACA,oC;AACA,E;;AAEA,G;AACA,yE;AACA,gB;AACA,+E;AACA,G;AACA,2C;AACA,2C;AACA,E;;;AAGA,mE;AACA,0C;AACA,E;AACA,iE;AACA,2C;AACA,wC;AACA,uB;AACA,E;;AAEA,oD;AACA,8C;AACA,Y;AACA,S;AACA,sE;AACA,K;AACA,e;AACA,8B;AACA,sE;AACA,uE;AACA,8C;AACA,sD;AACA,wB;AACA,kB;AACA,K;AACA,gB;AACA,8B;AACA,+D;AACA,oE;AACA,yB;AACA,iE;AACA,K;AACA,gB;AACA,K;AACA,E;;;AAGA,sD;AACA,wC;AACA,8D;AACA,gB;AACA,K;AACA,E;;AAEA,kD;AACA,+C;AACA,8D;AACA,gB;AACA,K;AACA,E;;;AAGA,G;AACA,iB;AACA,G;;AAEA,gE;AACA,mD;AACA,E;AACA,e;AACA,a;AACA,oB;AACA,E;AACA,gE;AACA,gE;AACA,kE;AACA,8B;AACA,E;AACA,sE;AACA,oB;AACA,E;AACA,E;AACA,4D;AACA,oE;AACA,U;AACA,E;AACA,U;AACA,+D;AACA,0B;AACA,E;AACA,W;AACA,sE;AACA,E;AACA,Y;AACA,8D;AACA,6C;AACA,E;AACA,a;AACA,mE;AACA,qC;AACA,E;AACA,uB;AACA,mE;AACA,gE;AACA,8B;AACA,E;AACA,oE;AACA,kE;AACA,sE;AACA,gE;AACA,uB;AACA,E;AACA,oE;AACA,kE;;;AAGA,mE;AACA,sE;AACA,qC;AACA,E;AACA,0C;AACA,a;AACA,O;AACA,kB;AACA,G;AACA,a;AACA,wB;AACA,G;;AAEA,qC;AACA,uB;;AAEA,gB;AACA,E;;;AAGA,iC;AACA,E;AACA,qE;AACA,sE;AACA,sE;AACA,kE;AACA,U;AACA,E;AACA,mE;AACA,oE;AACA,qE;AACA,2B;AACA,wE;AACA,4B;AACA,8D;AACA,0D;AACA,G;;AAEA,kE;AACA,2D;AACA,gE;AACA,yD;AACA,4D;AACA,iB;AACA,uC;AACA,4B;AACA,a;AACA,kC;AACA,uD;AACA,M;AACA,K;;AAEA,qC;;AAEA,U;AACA,e;AACA,mC;AACA,mE;AACA,I;AACA,E;;;AAGA,kE;AACA,oE;AACA,8D;AACA,E;AACA,qE;AACA,6B;AACA,E;AACA,gF;AACA,c;AACA,0C;;AAEA,8E;AACA,mE;AACA,8D;AACA,sC;AACA,wE;;AAEA,W;AACA,oB;AACA,+C;;AAEA,iB;AACA,mC;AACA,iD;AACA,2B;AACA,0C;AACA,I;AACA,mB;AACA,iC;AACA,W;AACA,wB;;AAEA,+E;AACA,+E;AACA,oC;AACA,sD;;AAEA,wB;AACA,uB;AACA,2E;AACA,0B;AACA,M;AACA,0D;AACA,e;AACA,G;AACA,Q;AACA,sD;AACA,wB;AACA,G;AACA,E;;;AAGA,sE;AACA,+D;AACA,8B;AACA,E;AACA,uF;AACA,sB;AACA,qB;AACA,e;AACA,e;AACA,4B;AACA,I;AACA,E;;;AAGA,sE;AACA,wE;AACA,oE;AACA,uE;AACA,sE;AACA,qE;AACA,yE;AACA,4F;AACA,iB;AACA,mC;AACA,mB;AACA,wB;AACA,2B;AACA,0C;AACA,I;AACA,oB;AACA,uD;;AAEA,sD;AACA,oD;AACA,wE;AACA,0B;AACA,iB;AACA,E;;;AAGA,G;AACA,kB;AACA,G;;AAEA,mC;AACA,uB;;AAEA,8D;AACA,E;AACA,oE;AACA,kE;AACA,E;AACA,oE;AACA,2D;AACA,E;AACA,uE;AACA,uE;AACA,uC;AACA,iC;;AAEA,yD;AACA,kB;AACA,mB;AACA,gB;AACA,G;AACA,qD;AACA,E;;;AAGA,+D;AACA,uE;AACA,qE;AACA,qE;AACA,wE;AACA,uE;AACA,E;AACA,kF;AACA,iE;AACA,wD;;AAEA,qE;AACA,sE;AACA,qB;AACA,6D;AACA,kD;AACA,mC;;AAEA,gC;AACA,mB;AACA,mB;AACA,+D;AACA,O;AACA,M;;AAEA,e;AACA,oB;AACA,kC;AACA,yF;AACA,G;;AAEA,U;AACA,e;AACA,0E;AACA,I;AACA,E;;AAEA,kD;AACA,E;AACA,8D;AACA,0C;AACA,E;AACA,oE;AACA,oE;AACA,sB;AACA,uD;AACA,+B;AACA,Y;AACA,sC;AACA,c;AACA,sC;AACA,+B;AACA,S;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,mE;AACA,8B;AACA,gB;AACA,2B;AACA,iE;AACA,+E;AACA,8C;AACA,4B;AACA,oB;;AAEA,6E;AACA,wC;AACA,2B;;AAEA,iD;;AAEA,0D;AACA,I;;AAEA,sB;AACA,4D;AACA,gE;AACA,6B;AACA,gD;AACA,yB;AACA,I;;AAEA,+E;AACA,0E;AACA,4E;AACA,0C;AACA,I;AACA,0B;AACA,uE;AACA,wE;AACA,qE;AACA,iE;AACA,qE;AACA,qE;AACA,iE;AACA,sE;AACA,0B;AACA,I;AACA,+D;AACA,mC;AACA,oB;AACA,kD;AACA,e;AACA,2C;AACA,O;AACA,O;AACA,e;AACA,iE;AACA,0E;AACA,+E;AACA,6E;AACA,c;AACA,oD;AACA,2D;AACA,+B;AACA,mC;AACA,e;AACA,wD;AACA,yD;AACA,U;AACA,sF;AACA,S;AACA,qC;AACA,gF;AACA,oC;AACA,0C;AACA,sD;AACA,mD;AACA,0E;AACA,6E;AACA,mB;AACA,c;AACA,8B;AACA,8D;AACA,Q;AACA,Y;AACA,uD;AACA,K;AACA,I;;AAEA,gE;AACA,wE;AACA,uE;AACA,oD;AACA,I;AACA,oB;AACA,kE;AACA,yC;AACA,4B;AACA,oB;AACA,kD;AACA,kD;AACA,O;AACA,kC;AACA,uD;AACA,K;AACA,8D;AACA,oE;AACA,uE;AACA,qB;AACA,yE;AACA,qC;AACA,uC;AACA,+B;AACA,+D;AACA,O;AACA,M;AACA,yE;AACA,oD;AACA,K;AACA,gE;AACA,oD;AACA,6D;AACA,yD;AACA,I;;AAEA,oE;AACA,gE;AACA,oC;AACA,kC;AACA,oB;AACA,wB;AACA,uD;AACA,K;AACA,mE;AACA,sC;AACA,c;AACA,6E;AACA,O;AACA,O;AACA,G;AACA,G;;AAEA,G;AACA,gB;AACA,G;;AAEA,2C;AACA,qB;;AAEA,sE;AACA,6D;AACA,2D;AACA,uC;AACA,6B;AACA,E;;AAEA,kE;AACA,uC;;AAEA,uE;AACA,kD;AACA,Y;AACA,W;;AAEA,0B;AACA,uB;AACA,M;AACA,wB;AACA,E;;AAEA,kD;AACA,wD;AACA,kC;AACA,6C;AACA,sC;AACA,K;AACA,G;;;AAGA,G;AACA,oB;AACA,G;AACA,mD;;AAEA,kD;AACA,yC;AACA,0B;AACA,+B;AACA,E;;;AAGA,uC;AACA,sD;AACA,kB;AACA,kC;AACA,+D;AACA,I;AACA,E;;;AAGA,kE;AACA,gE;AACA,S;AACA,0E;AACA,sC;AACA,qB;AACA,sB;AACA,U;AACA,kB;AACA,kD;AACA,O;AACA,I;AACA,E;;;AAGA,sB;AACA,qE;AACA,mC;AACA,W;AACA,6C;AACA,S;AACA,I;AACA,E;;;AAGA,mD;AACA,sB;AACA,W;AACA,+C;AACA,I;AACA,E;;AAEA,gE;AACA,wE;AACA,mD;AACA,oC;;AAEA,Y;AACA,oD;AACA,kD;AACA,E;;AAEA,uE;AACA,qE;AACA,c;AACA,yD;AACA,wD;AACA,2D;AACA,2B;AACA,+D;AACA,kE;AACA,kE;AACA,mE;AACA,sD;AACA,Y;AACA,sD;AACA,qB;AACA,K;AACA,G;AACA,E;;AAEA,mD;AACA,8D;AACA,E;;AAEA,8B;AACA,mE;AACA,2C;AACA,kE;;AAEA,iB;AACA,wE;AACA,qE;AACA,wE;AACA,qE;AACA,8B;AACA,M;AACA,sE;AACA,uE;AACA,2D;AACA,wE;AACA,wE;AACA,wE;AACA,qD;AACA,qD;AACA,8B;AACA,4B;AACA,qE;AACA,kE;AACA,gE;AACA,uC;AACA,oB;AACA,2D;AACA,iD;AACA,4B;AACA,mC;AACA,U;AACA,8B;AACA,6B;AACA,kE;AACA,uE;AACA,0B;AACA,S;AACA,S;;AAEA,4E;AACA,4E;AACA,qD;AACA,Q;AACA,0E;AACA,gF;AACA,yE;AACA,+E;AACA,8D;AACA,uB;AACA,e;AACA,O;;AAEA,+D;AACA,iE;AACA,4E;AACA,O;;AAEA,0D;;AAEA,gC;AACA,0E;AACA,wE;AACA,wE;AACA,uE;AACA,6D;AACA,2B;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,mC;AACA,2D;AACA,sB;AACA,qB;;AAEA,gC;;AAEA,6D;;AAEA,mE;AACA,sE;AACA,a;AACA,kC;AACA,8D;;AAEA,e;AACA,qE;AACA,oE;AACA,kE;AACA,qE;AACA,2B;AACA,iC;AACA,Y;AACA,iE;AACA,6D;AACA,O;AACA,O;AACA,G;;AAEA,a;AACA,Y;AACA,gG;AACA,M;;AAEA,+D;AACA,mE;AACA,oB;AACA,4B;AACA,yE;AACA,6C;AACA,K;AACA,c;AACA,kC;AACA,U;AACA,uE;AACA,4C;AACA,O;AACA,iC;AACA,G;;AAEA,2D;AACA,iC;AACA,Y;AACA,uB;AACA,oF;AACA,M;;AAEA,oE;AACA,8B;AACA,oE;AACA,mE;AACA,kE;AACA,oE;AACA,qC;AACA,wB;AACA,O;AACA,sB;AACA,2D;AACA,Q;AACA,mB;AACA,wC;AACA,qC;AACA,4B;AACA,S;AACA,Q;AACA,M;;AAEA,mE;AACA,sE;AACA,0D;AACA,mC;AACA,c;AACA,kE;AACA,O;AACA,O;AACA,G;;AAEA,U;AACA,qB;AACA,wB;AACA,4B;AACA,sB;AACA,K;AACA,I;AACA,G;;AAEA,mD;AACA,E;AACA,mD;AACA,oD;AACA,E;;AAEA,G;AACA,oB;AACA,G;;AAEA,wB;;AAEA,2E;AACA,gC;AACA,E;AACA,2D;AACA,qE;AACA,sE;AACA,4B;AACA,gF;AACA,6C;;AAEA,0E;AACA,qE;AACA,+E;AACA,G;;AAEA,sC;AACA,6C;AACA,+C;;;AAGA,+E;AACA,2B;AACA,4C;AACA,U;AACA,uE;AACA,uE;AACA,K;AACA,O;AACA,Y;AACA,sC;AACA,c;AACA,6C;AACA,6C;AACA,S;AACA,O;AACA,K;AACA,sB;AACA,0E;AACA,oB;AACA,E;;AAEA,6C;AACA,0D;AACA,yD;AACA,4B;AACA,8C;AACA,+B;AACA,G;AACA,E;;AAEA,sD;AACA,oE;;;AAGA,G;AACA,4B;AACA,G;;AAEA,iG;;;AAGA,wC;AACA,0D;AACA,E;;;AAGA,sE;AACA,sE;AACA,kE;AACA,sE;AACA,gE;AACA,wB;AACA,E;AACA,+D;AACA,8C;AACA,iC;AACA,2D;AACA,wE;AACA,6B;AACA,K;AACA,E;;;AAGA,qE;AACA,S;AACA,E;AACA,kE;AACA,qE;AACA,kE;AACA,kE;AACA,mD;;AAEA,4B;AACA,8B;AACA,W;;AAEA,4B;AACA,0D;;AAEA,oD;AACA,kC;AACA,8C;AACA,U;AACA,+B;AACA,iD;AACA,mB;AACA,iB;AACA,qD;AACA,W;AACA,Q;AACA,O;AACA,G;;;AAGA,G;AACA,qB;AACA,G;;AAEA,4B;;AAEA,G;AACA,wC;AACA,gB;AACA,uI;AACA,G;AACA,yC;AACA,uB;AACA,uD;AACA,M;AACA,4B;AACA,E;;AAEA,4E;AACA,oC;AACA,sD;AACA,sB;AACA,mC;AACA,c;AACA,E;;AAEA,8B;AACA,mD;AACA,wD;AACA,8B;AACA,mE;AACA,4C;AACA,I;AACA,oE;AACA,iD;AACA,mE;AACA,iE;AACA,kE;AACA,iE;AACA,iB;AACA,mE;;AAEA,oB;AACA,kD;AACA,sD;AACA,O;;AAEA,e;AACA,yB;AACA,+C;;AAEA,2E;AACA,yE;AACA,iE;AACA,yC;AACA,sD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,wB;AACA,4D;AACA,K;;AAEA,a;AACA,O;AACA,2C;AACA,e;AACA,sC;AACA,yE;AACA,yC;AACA,yE;AACA,wB;AACA,mD;AACA,2D;AACA,4C;AACA,8D;AACA,yE;AACA,Y;AACA,G;AACA,gB;AACA,E;;AAEA,8B;;AAEA,G;AACA,kD;AACA,gB;AACA,qJ;AACA,G;AACA,4C;AACA,kC;AACA,E;;AAEA,oD;AACA,+D;AACA,+D;AACA,gC;AACA,gD;AACA,E;;AAEA,6E;AACA,qB;AACA,wC;AACA,+D;AACA,mB;AACA,8C;AACA,0B;AACA,oE;AACA,E;;AAEA,sE;AACA,0C;AACA,+D;AACA,c;AACA,gB;;AAEA,0B;AACA,gC;AACA,uD;AACA,4C;AACA,O;AACA,yC;AACA,iD;AACA,2D;AACA,6D;AACA,O;AACA,G;;AAEA,kB;AACA,gB;;AAEA,yB;AACA,kE;AACA,M;AACA,qE;AACA,G;;AAEA,G;AACA,yB;AACA,G;;AAEA,oE;AACA,E;AACA,0D;AACA,iE;AACA,iE;AACA,mE;AACA,2E;AACA,uB;AACA,mE;AACA,gC;AACA,E;AACA,0D;AACA,sC;AACA,mC;;AAEA,6D;AACA,oB;AACA,8E;AACA,uB;AACA,gC;AACA,oB;AACA,sE;;AAEA,0D;AACA,oB;AACA,uD;;AAEA,yD;AACA,wE;AACA,wE;AACA,qE;AACA,4E;AACA,6E;AACA,sE;AACA,4D;AACA,8B;AACA,sD;AACA,oE;AACA,U;AACA,4C;AACA,G;;AAEA,4C;;AAEA,a;AACA,oD;;AAEA,6E;AACA,yE;AACA,6D;AACA,mE;AACA,0B;AACA,sB;AACA,8C;AACA,8D;AACA,O;;AAEA,6E;AACA,2B;AACA,oD;AACA,Y;AACA,wB;AACA,sB;AACA,M;AACA,U;AACA,6E;AACA,qB;AACA,0B;AACA,6C;AACA,Y;AACA,wB;AACA,mD;AACA,M;AACA,G;AACA,E;;;AAGA,G;AACA,mB;AACA,G;;AAEA,mD;AACA,iC;AACA,oB;AACA,6B;AACA,yB;AACA,sD;AACA,U;AACA,gB;AACA,G;AACA,oD;;AAEA,iE;AACA,wD;AACA,qE;AACA,iE;AACA,kE;AACA,yB;AACA,kD;AACA,qC;AACA,E;;AAEA,6D;AACA,gE;AACA,8C;AACA,E;AACA,6B;AACA,8E;AACA,qF;AACA,gD;AACA,4C;AACA,0D;AACA,0C;AACA,sD;AACA,E;;AAEA,0B;AACA,+D;AACA,0B;AACA,8B;AACA,2D;AACA,4C;AACA,qD;AACA,0B;AACA,U;AACA,M;;AAEA,6C;AACA,wB;AACA,iC;AACA,6B;AACA,qE;AACA,c;AACA,oB;AACA,O;AACA,wD;;AAEA,gF;AACA,8E;AACA,6E;AACA,+E;AACA,gE;AACA,6C;AACA,mB;AACA,sB;AACA,6C;AACA,U;AACA,sB;;AAEA,+B;AACA,iB;AACA,iE;AACA,wD;AACA,K;AACA,C;;AAEA,oE;AACA,gE;AACA,4B;AACA,0D;AACA,6E;AACA,2E;;AAEA,oE;AACA,wD;AACA,gB;AACA,+C;AACA,6D;AACA,0E;AACA,yE;AACA,wB;AACA,2E;AACA,wE;AACA,0B;AACA,wB;AACA,2E;AACA,qD;AACA,K;;AAEA,8B;AACA,4D;AACA,gF;AACA,wF;;AAEA,2D;AACA,4D;;AAEA,wD;AACA,G;AACA,G;;;AAGA,G;AACA,sC;AACA,G;;AAEA,oB;AACA,oE;AACA,kB;AACA,qD;AACA,iC;AACA,4B;AACA,mB;;AAEA,iE;AACA,sE;AACA,0B;AACA,uD;AACA,mB;;AAEA,gB;AACA,I;AACA,wC;AACA,G;;AAEA,4B;AACA,8D;AACA,oE;AACA,oE;AACA,kD;AACA,8D;AACA,kD;AACA,6E;AACA,gB;AACA,oE;AACA,yC;AACA,4B;AACA,6E;;AAEA,G;AACA,qC;AACA,G;;AAEA,2D;AACA,uB;AACA,iC;AACA,e;AACA,qD;AACA,gD;AACA,Q;AACA,iB;AACA,qD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,4B;AACA,6E;AACA,2E;AACA,gF;AACA,gF;AACA,0E;AACA,Y;AACA,iC;AACA,mD;AACA,M;AACA,4C;AACA,K;AACA,iC;AACA,0E;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACn2CA,oD;;AAEA,mB;;AAEA,gD;AACA,yD;AACA,E;;AAEA,8C;AACA,uD;AACA,E;;AAEA,gD;AACA,yD;AACA,E","file":"/packages/accounts-base.js","sourcesContent":["/**\n * @namespace Accounts\n * @summary The namespace for all accounts-related methods.\n */\nAccounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// how long (in days) until a login token expires\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\n// Clients don't try to auto-login with a token that is going to expire within\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\n// Tries to avoid abrupt disconnects from expiring tokens.\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\n// how often (in milliseconds) we check for expired tokens\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\n// called\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n// - restrictCreationByEmailDomain {Function or String}\n//     Require created users to have an email matching the function or\n//     having the string as domain.\n// - loginExpirationInDays {Number}\n//     Number of days since login until a user is logged out (login token\n//     expires).\n\n/**\n * @summary Set global accounts options.\n * @locus Anywhere\n * @param {Object} options\n * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\n * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \"Create account\" link will not be available.\n * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\n * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\n * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specifed on the server.  See packages/oauth-encryption/README.md for details.\n */\nAccounts.config = function(options) {\n  // We don't want users to accidentally only call Accounts.config on the\n  // client, where some of the options will have partial effects (eg removing\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\n  // is set, or redirecting Google login to a specific-domain page) without\n  // having their full effects.\n  if (Meteor.isServer) {\n    __meteor_runtime_config__.accountsConfigCalled = true;\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\n    // message, but there's no trivial way to do this.\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\n                  \"server; some configuration options may not take effect.\");\n  }\n\n  // We need to validate the oauthSecretKey option at the time\n  // Accounts.config is called. We also deliberately don't store the\n  // oauthSecretKey in Accounts._options.\n  if (_.has(options, \"oauthSecretKey\")) {\n    if (Meteor.isClient)\n      throw new Error(\"The oauthSecretKey option may only be specified on the server\");\n    if (! Package[\"oauth-encryption\"])\n      throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");\n    Package[\"oauth-encryption\"].OAuthEncryption.loadKey(options.oauthSecretKey);\n    options = _.omit(options, \"oauthSecretKey\");\n  }\n\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n\n  // If the user set loginExpirationInDays to null, then we need to clear the\n  // timer that periodically expires tokens.\n  if (Meteor.isServer)\n    maybeStopExpireTokensInterval();\n};\n\nif (Meteor.isClient) {\n  // The connection used by the Accounts system. This is the connection\n  // that will get logged in by Meteor.login(), and this is the\n  // connection whose login state will be reflected by Meteor.userId().\n  //\n  // It would be much preferable for this to be in accounts_client.js,\n  // but it has to be here because it's needed to create the\n  // Meteor.users collection.\n  Accounts.connection = Meteor.connection;\n\n  if (typeof __meteor_runtime_config__ !== \"undefined\" &&\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\n    // Temporary, internal hook to allow the server to point the client\n    // to a different authentication server. This is for a very\n    // particular use case that comes up when implementing a oauth\n    // server. Unsupported and may go away at any point in time.\n    //\n    // We will eventually provide a general way to use account-base\n    // against any DDP connection, not just one special one.\n    Accounts.connection = DDP.connect(\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL)\n  }\n}\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n\n/**\n * @summary A [Mongo.Collection](#collections) containing user documents.\n * @locus Anywhere\n * @type {Mongo.Collection}\n */\nMeteor.users = new Mongo.Collection(\"users\", {\n  _preventAutopublish: true,\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nMeteor.startup(function () {\n  var ServiceConfiguration =\n    Package['service-configuration'].ServiceConfiguration;\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\n});\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\ngetTokenLifetimeMs = function () {\n  return (Accounts._options.loginExpirationInDays ||\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n};\n\nAccounts._tokenExpiration = function (when) {\n  // We pass when through the Date constructor for backwards compatibility;\n  // `when` used to be a number.\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\n};\n\nAccounts._tokenExpiresSoon = function (when) {\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\n  if (minLifetimeMs > minLifetimeCapMs)\n    minLifetimeMs = minLifetimeCapMs;\n  return new Date() > (new Date(when) - minLifetimeMs);\n};\n","var crypto = Npm.require('crypto');\n\n///\n/// CURRENT USER\n///\n\nMeteor.userId = function () {\n  // This function only works if called inside a method. In theory, it\n  // could also be called from publish statements, since they also\n  // have a userId associated with them. However, given that publish\n  // functions aren't reactive, using any of the infomation from\n  // Meteor.user() in a publish function will always use the value\n  // from when the function first runs. This is likely not what the\n  // user expects. The way to make this work in a publish is to do\n  // Meteor.find(this.userId()).observe and recompute when the user\n  // record changes.\n  var currentInvocation = DDP._CurrentInvocation.get();\n  if (!currentInvocation)\n    throw new Error(\"Meteor.userId can only be invoked in method calls. Use this.userId in publish functions.\");\n  return currentInvocation.userId;\n};\n\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n\n///\n/// LOGIN HOOKS\n///\n\n// Exceptions inside the hook callback are passed up to us.\nvar validateLoginHook = new Hook();\n\n// Callback exceptions are printed with Meteor._debug and ignored.\nvar onLoginHook = new Hook({\n  debugPrintExceptions: \"onLogin callback\"\n});\nvar onLoginFailureHook = new Hook({\n  debugPrintExceptions: \"onLoginFailure callback\"\n});\n\n/**\n * @summary Validate login attempts.\n * @locus Server\n * @param {Function} func Called whenever a login is attempted (either successful or unsuccessful).  A login can be aborted by returning a falsy value or throwing an exception.\n */\nAccounts.validateLoginAttempt = function (func) {\n  return validateLoginHook.register(func);\n};\n\n/**\n * @summary Register a callback to be called after a login attempt succeeds.\n * @locus Server\n * @param {Function} func The callback to be called when login is successful.\n */\nAccounts.onLogin = function (func) {\n  return onLoginHook.register(func);\n};\n\n/**\n * @summary Register a callback to be called after a login attempt fails.\n * @locus Server\n * @param {Function} func The callback to be called after the login has failed.\n */\nAccounts.onLoginFailure = function (func) {\n  return onLoginFailureHook.register(func);\n};\n\n\n// Give each login hook callback a fresh cloned copy of the attempt\n// object, but don't clone the connection.\n//\nvar cloneAttemptWithConnection = function (connection, attempt) {\n  var clonedAttempt = EJSON.clone(attempt);\n  clonedAttempt.connection = connection;\n  return clonedAttempt;\n};\n\nvar validateLogin = function (connection, attempt) {\n  validateLoginHook.each(function (callback) {\n    var ret;\n    try {\n      ret = callback(cloneAttemptWithConnection(connection, attempt));\n    }\n    catch (e) {\n      attempt.allowed = false;\n      // XXX this means the last thrown error overrides previous error\n      // messages. Maybe this is surprising to users and we should make\n      // overriding errors more explicit. (see\n      // https://github.com/meteor/meteor/issues/1960)\n      attempt.error = e;\n      return true;\n    }\n    if (! ret) {\n      attempt.allowed = false;\n      // don't override a specific error provided by a previous\n      // validator or the initial attempt (eg \"incorrect password\").\n      if (!attempt.error)\n        attempt.error = new Meteor.Error(403, \"Login forbidden\");\n    }\n    return true;\n  });\n};\n\n\nvar successfulLogin = function (connection, attempt) {\n  onLoginHook.each(function (callback) {\n    callback(cloneAttemptWithConnection(connection, attempt));\n    return true;\n  });\n};\n\nvar failedLogin = function (connection, attempt) {\n  onLoginFailureHook.each(function (callback) {\n    callback(cloneAttemptWithConnection(connection, attempt));\n    return true;\n  });\n};\n\n\n///\n/// LOGIN METHODS\n///\n\n// Login methods return to the client an object containing these\n// fields when the user was logged in successfully:\n//\n//   id: userId\n//   token: *\n//   tokenExpires: *\n//\n// tokenExpires is optional and intends to provide a hint to the\n// client as to when the token will expire. If not provided, the\n// client will call Accounts._tokenExpiration, passing it the date\n// that it received the token.\n//\n// The login method will throw an error back to the client if the user\n// failed to log in.\n//\n//\n// Login handlers and service specific login methods such as\n// `createUser` internally return a `result` object containing these\n// fields:\n//\n//   type:\n//     optional string; the service name, overrides the handler\n//     default if present.\n//\n//   error:\n//     exception; if the user is not allowed to login, the reason why.\n//\n//   userId:\n//     string; the user id of the user attempting to login (if\n//     known), required for an allowed login.\n//\n//   options:\n//     optional object merged into the result returned by the login\n//     method; used by HAMK from SRP.\n//\n//   stampedLoginToken:\n//     optional object with `token` and `when` indicating the login\n//     token is already present in the database, returned by the\n//     \"resume\" login handler.\n//\n// For convenience, login methods can also throw an exception, which\n// is converted into an {error} result.  However, if the id of the\n// user attempting the login is known, a {userId, error} result should\n// be returned instead since the user id is not captured when an\n// exception is thrown.\n//\n// This internal `result` object is automatically converted into the\n// public {id, token, tokenExpires} object returned to the client.\n\n\n// Try a login method, converting thrown exceptions into an {error}\n// result.  The `type` argument is a default, inserted into the result\n// object if not explicitly returned.\n//\nvar tryLoginMethod = function (type, fn) {\n  var result;\n  try {\n    result = fn();\n  }\n  catch (e) {\n    result = {error: e};\n  }\n\n  if (result && !result.type && type)\n    result.type = type;\n\n  return result;\n};\n\n\n// Log in a user on a connection.\n//\n// We use the method invocation to set the user id on the connection,\n// not the connection object directly. setUserId is tied to methods to\n// enforce clear ordering of method application (using wait methods on\n// the client, and a no setUserId after unblock restriction on the\n// server)\n//\n// The `stampedLoginToken` parameter is optional.  When present, it\n// indicates that the login token has already been inserted into the\n// database and doesn't need to be inserted again.  (It's used by the\n// \"resume\" login handler).\nvar loginUser = function (methodInvocation, userId, stampedLoginToken) {\n  if (! stampedLoginToken) {\n    stampedLoginToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedLoginToken);\n  }\n\n  // This order (and the avoidance of yields) is important to make\n  // sure that when publish functions are rerun, they see a\n  // consistent view of the world: the userId is set and matches\n  // the login token on the connection (not that there is\n  // currently a public API for reading the login token on a\n  // connection).\n  Meteor._noYieldsAllowed(function () {\n    Accounts._setLoginToken(\n      userId,\n      methodInvocation.connection,\n      Accounts._hashLoginToken(stampedLoginToken.token)\n    );\n  });\n\n  methodInvocation.setUserId(userId);\n\n  return {\n    id: userId,\n    token: stampedLoginToken.token,\n    tokenExpires: Accounts._tokenExpiration(stampedLoginToken.when)\n  };\n};\n\n\n// After a login method has completed, call the login hooks.  Note\n// that `attemptLogin` is called for *all* login attempts, even ones\n// which aren't successful (such as an invalid password, etc).\n//\n// If the login is allowed and isn't aborted by a validate login hook\n// callback, log in the user.\n//\nvar attemptLogin = function (methodInvocation, methodName, methodArgs, result) {\n  if (!result)\n    throw new Error(\"result is required\");\n\n  // XXX A programming error in a login handler can lead to this occuring, and\n  // then we don't call onLogin or onLoginFailure callbacks. Should\n  // tryLoginMethod catch this case and turn it into an error?\n  if (!result.userId && !result.error)\n    throw new Error(\"A login method must specify a userId or an error\");\n\n  var user;\n  if (result.userId)\n    user = Meteor.users.findOne(result.userId);\n\n  var attempt = {\n    type: result.type || \"unknown\",\n    allowed: !! (result.userId && !result.error),\n    methodName: methodName,\n    methodArguments: _.toArray(methodArgs)\n  };\n  if (result.error)\n    attempt.error = result.error;\n  if (user)\n    attempt.user = user;\n\n  // validateLogin may mutate `attempt` by adding an error and changing allowed\n  // to false, but that's the only change it can make (and the user's callbacks\n  // only get a clone of `attempt`).\n  validateLogin(methodInvocation.connection, attempt);\n\n  if (attempt.allowed) {\n    var ret = _.extend(\n      loginUser(methodInvocation, result.userId, result.stampedLoginToken),\n      result.options || {}\n    );\n    successfulLogin(methodInvocation.connection, attempt);\n    return ret;\n  }\n  else {\n    failedLogin(methodInvocation.connection, attempt);\n    throw attempt.error;\n  }\n};\n\n\n// All service specific login methods should go through this function.\n// Ensure that thrown exceptions are caught and that login hook\n// callbacks are still called.\n//\nAccounts._loginMethod = function (methodInvocation, methodName, methodArgs, type, fn) {\n  return attemptLogin(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    tryLoginMethod(type, fn)\n  );\n};\n\n\n// Report a login attempt failed outside the context of a normal login\n// method. This is for use in the case where there is a multi-step login\n// procedure (eg SRP based password login). If a method early in the\n// chain fails, it should call this function to report a failure. There\n// is no corresponding method for a successful login; methods that can\n// succeed at logging a user in should always be actual login methods\n// (using either Accounts._loginMethod or Accounts.registerLoginHandler).\nAccounts._reportLoginFailure = function (methodInvocation, methodName, methodArgs, result) {\n  var attempt = {\n    type: result.type || \"unknown\",\n    allowed: false,\n    error: result.error,\n    methodName: methodName,\n    methodArguments: _.toArray(methodArgs)\n  };\n  if (result.userId)\n    attempt.user = Meteor.users.findOne(result.userId);\n\n  validateLogin(methodInvocation.connection, attempt);\n  failedLogin(methodInvocation.connection, attempt);\n  // validateLogin may mutate attempt to set a new error message. Return\n  // the modified version.\n  return attempt;\n};\n\n\n///\n/// LOGIN HANDLERS\n///\n\n// list of all registered handlers.\nvar loginHandlers = [];\n\n// The main entry point for auth packages to hook in to login.\n//\n// A login handler is a login method which can return `undefined` to\n// indicate that the login request is not handled by this handler.\n//\n// @param name {String} Optional.  The service name, used by default\n// if a specific service name isn't returned in the result.\n//\n// @param handler {Function} A function that receives an options object\n// (as passed as an argument to the `login` method) and returns one of:\n// - `undefined`, meaning don't handle;\n// - a login method result object\n\nAccounts.registerLoginHandler = function(name, handler) {\n  if (! handler) {\n    handler = name;\n    name = null;\n  }\n  loginHandlers.push({name: name, handler: handler});\n};\n\n\n// Checks a user's credentials against all the registered login\n// handlers, and returns a login token if the credentials are valid. It\n// is like the login method, except that it doesn't set the logged-in\n// user on the connection. Throws a Meteor.Error if logging in fails,\n// including the case where none of the login handlers handled the login\n// request. Otherwise, returns {id: userId, token: *, tokenExpires: *}.\n//\n// For example, if you want to login with a plaintext password, `options` could be\n//   { user: { username: <username> }, password: <password> }, or\n//   { user: { email: <email> }, password: <password> }.\n\n// Try all of the registered login handlers until one of them doesn't\n// return `undefined`, meaning it handled this call to `login`. Return\n// that return value.\nvar runLoginHandlers = function (methodInvocation, options) {\n  for (var i = 0; i < loginHandlers.length; ++i) {\n    var handler = loginHandlers[i];\n\n    var result = tryLoginMethod(\n      handler.name,\n      function () {\n        return handler.handler.call(methodInvocation, options);\n      }\n    );\n\n    if (result)\n      return result;\n    else if (result !== undefined)\n      throw new Meteor.Error(400, \"A login handler should return a result or undefined\");\n  }\n\n  return {\n    type: null,\n    error: new Meteor.Error(400, \"Unrecognized options for login request\")\n  };\n};\n\n// Deletes the given loginToken from the database.\n//\n// For new-style hashed token, this will cause all connections\n// associated with the token to be closed.\n//\n// Any connections associated with old-style unhashed tokens will be\n// in the process of becoming associated with hashed tokens and then\n// they'll get closed.\nAccounts.destroyToken = function (userId, loginToken) {\n  Meteor.users.update(userId, {\n    $pull: {\n      \"services.resume.loginTokens\": {\n        $or: [\n          { hashedToken: loginToken },\n          { token: loginToken }\n        ]\n      }\n    }\n  });\n};\n\n// Actual methods for login and logout. This is the entry point for\n// clients to actually log in.\nMeteor.methods({\n  // @returns {Object|null}\n  //   If successful, returns {token: reconnectToken, id: userId}\n  //   If unsuccessful (for example, if the user closed the oauth login popup),\n  //     throws an error describing the reason\n  login: function(options) {\n    var self = this;\n\n    // Login handlers should really also check whatever field they look at in\n    // options, but we don't enforce it.\n    check(options, Object);\n\n    var result = runLoginHandlers(self, options);\n\n    return attemptLogin(self, \"login\", arguments, result);\n  },\n\n  logout: function() {\n    var token = Accounts._getLoginToken(this.connection.id);\n    Accounts._setLoginToken(this.userId, this.connection, null);\n    if (token && this.userId)\n      Accounts.destroyToken(this.userId, token);\n    this.setUserId(null);\n  },\n\n  // Delete all the current user's tokens and close all open connections logged\n  // in as this user. Returns a fresh new login token that this client can\n  // use. Tests set Accounts._noConnectionCloseDelayForTest to delete tokens\n  // immediately instead of using a delay.\n  //\n  // XXX COMPAT WITH 0.7.2\n  // This single `logoutOtherClients` method has been replaced with two\n  // methods, one that you call to get a new token, and another that you\n  // call to remove all tokens except your own. The new design allows\n  // clients to know when other clients have actually been logged\n  // out. (The `logoutOtherClients` method guarantees the caller that\n  // the other clients will be logged out at some point, but makes no\n  // guarantees about when.) This method is left in for backwards\n  // compatibility, especially since application code might be calling\n  // this method directly.\n  //\n  // @returns {Object} Object with token and tokenExpires keys.\n  logoutOtherClients: function () {\n    var self = this;\n    var user = Meteor.users.findOne(self.userId, {\n      fields: {\n        \"services.resume.loginTokens\": true\n      }\n    });\n    if (user) {\n      // Save the current tokens in the database to be deleted in\n      // CONNECTION_CLOSE_DELAY_MS ms. This gives other connections in the\n      // caller's browser time to find the fresh token in localStorage. We save\n      // the tokens in the database in case we crash before actually deleting\n      // them.\n      var tokens = user.services.resume.loginTokens;\n      var newToken = Accounts._generateStampedLoginToken();\n      var userId = self.userId;\n      Meteor.users.update(userId, {\n        $set: {\n          \"services.resume.loginTokensToDelete\": tokens,\n          \"services.resume.haveLoginTokensToDelete\": true\n        },\n        $push: { \"services.resume.loginTokens\": Accounts._hashStampedToken(newToken) }\n      });\n      Meteor.setTimeout(function () {\n        // The observe on Meteor.users will take care of closing the connections\n        // associated with `tokens`.\n        deleteSavedTokens(userId, tokens);\n      }, Accounts._noConnectionCloseDelayForTest ? 0 :\n                        CONNECTION_CLOSE_DELAY_MS);\n      // We do not set the login token on this connection, but instead the\n      // observe closes the connection and the client will reconnect with the\n      // new token.\n      return {\n        token: newToken.token,\n        tokenExpires: Accounts._tokenExpiration(newToken.when)\n      };\n    } else {\n      throw new Meteor.Error(\"You are not logged in.\");\n    }\n  },\n\n  // Generates a new login token with the same expiration as the\n  // connection's current token and saves it to the database. Associates\n  // the connection with this new token and returns it. Throws an error\n  // if called on a connection that isn't logged in.\n  //\n  // @returns Object\n  //   If successful, returns { token: <new token>, id: <user id>,\n  //   tokenExpires: <expiration date> }.\n  getNewToken: function () {\n    var self = this;\n    var user = Meteor.users.findOne(self.userId, {\n      fields: { \"services.resume.loginTokens\": 1 }\n    });\n    if (! self.userId || ! user) {\n      throw new Meteor.Error(\"You are not logged in.\");\n    }\n    // Be careful not to generate a new token that has a later\n    // expiration than the curren token. Otherwise, a bad guy with a\n    // stolen token could use this method to stop his stolen token from\n    // ever expiring.\n    var currentHashedToken = Accounts._getLoginToken(self.connection.id);\n    var currentStampedToken = _.find(\n      user.services.resume.loginTokens,\n      function (stampedToken) {\n        return stampedToken.hashedToken === currentHashedToken;\n      }\n    );\n    if (! currentStampedToken) { // safety belt: this should never happen\n      throw new Meteor.Error(\"Invalid login token\");\n    }\n    var newStampedToken = Accounts._generateStampedLoginToken();\n    newStampedToken.when = currentStampedToken.when;\n    Accounts._insertLoginToken(self.userId, newStampedToken);\n    return loginUser(self, self.userId, newStampedToken);\n  },\n\n  // Removes all tokens except the token associated with the current\n  // connection. Throws an error if the connection is not logged\n  // in. Returns nothing on success.\n  removeOtherTokens: function () {\n    var self = this;\n    if (! self.userId) {\n      throw new Meteor.Error(\"You are not logged in.\");\n    }\n    var currentToken = Accounts._getLoginToken(self.connection.id);\n    Meteor.users.update(self.userId, {\n      $pull: {\n        \"services.resume.loginTokens\": { hashedToken: { $ne: currentToken } }\n      }\n    });\n  }\n});\n\n///\n/// ACCOUNT DATA\n///\n\n// connectionId -> {connection, loginToken}\nvar accountData = {};\n\n// HACK: This is used by 'meteor-accounts' to get the loginToken for a\n// connection. Maybe there should be a public way to do that.\nAccounts._getAccountData = function (connectionId, field) {\n  var data = accountData[connectionId];\n  return data && data[field];\n};\n\nAccounts._setAccountData = function (connectionId, field, value) {\n  var data = accountData[connectionId];\n\n  // safety belt. shouldn't happen. accountData is set in onConnection,\n  // we don't have a connectionId until it is set.\n  if (!data)\n    return;\n\n  if (value === undefined)\n    delete data[field];\n  else\n    data[field] = value;\n};\n\nMeteor.server.onConnection(function (connection) {\n  accountData[connection.id] = {connection: connection};\n  connection.onClose(function () {\n    removeTokenFromConnection(connection.id);\n    delete accountData[connection.id];\n  });\n});\n\n\n///\n/// RECONNECT TOKENS\n///\n/// support reconnecting using a meteor login token\n\nAccounts._hashLoginToken = function (loginToken) {\n  var hash = crypto.createHash('sha256');\n  hash.update(loginToken);\n  return hash.digest('base64');\n};\n\n\n// {token, when} => {hashedToken, when}\nAccounts._hashStampedToken = function (stampedToken) {\n  return _.extend(\n    _.omit(stampedToken, 'token'),\n    {hashedToken: Accounts._hashLoginToken(stampedToken.token)}\n  );\n};\n\n\n// Using $addToSet avoids getting an index error if another client\n// logging in simultaneously has already inserted the new hashed\n// token.\nAccounts._insertHashedLoginToken = function (userId, hashedToken, query) {\n  query = query ? _.clone(query) : {};\n  query._id = userId;\n  Meteor.users.update(\n    query,\n    { $addToSet: {\n        \"services.resume.loginTokens\": hashedToken\n    } }\n  );\n};\n\n\n// Exported for tests.\nAccounts._insertLoginToken = function (userId, stampedToken, query) {\n  Accounts._insertHashedLoginToken(\n    userId,\n    Accounts._hashStampedToken(stampedToken),\n    query\n  );\n};\n\n\nAccounts._clearAllLoginTokens = function (userId) {\n  Meteor.users.update(\n    userId,\n    {$set: {'services.resume.loginTokens': []}}\n  );\n};\n\n// connection id -> observe handle for the login token that this\n// connection is currently associated with, or null. Null indicates that\n// we are in the process of setting up the observe.\nvar userObservesForConnections = {};\n\n// test hook\nAccounts._getUserObserve = function (connectionId) {\n  return userObservesForConnections[connectionId];\n};\n\n// Clean up this connection's association with the token: that is, stop\n// the observe that we started when we associated the connection with\n// this token.\nvar removeTokenFromConnection = function (connectionId) {\n  if (_.has(userObservesForConnections, connectionId)) {\n    var observe = userObservesForConnections[connectionId];\n    if (observe === null) {\n      // We're in the process of setting up an observe for this\n      // connection. We can't clean up that observe yet, but if we\n      // delete the null placeholder for this connection, then the\n      // observe will get cleaned up as soon as it has been set up.\n      delete userObservesForConnections[connectionId];\n    } else {\n      delete userObservesForConnections[connectionId];\n      observe.stop();\n    }\n  }\n};\n\nAccounts._getLoginToken = function (connectionId) {\n  return Accounts._getAccountData(connectionId, 'loginToken');\n};\n\n// newToken is a hashed token.\nAccounts._setLoginToken = function (userId, connection, newToken) {\n  removeTokenFromConnection(connection.id);\n  Accounts._setAccountData(connection.id, 'loginToken', newToken);\n\n  if (newToken) {\n    // Set up an observe for this token. If the token goes away, we need\n    // to close the connection.  We defer the observe because there's\n    // no need for it to be on the critical path for login; we just need\n    // to ensure that the connection will get closed at some point if\n    // the token gets deleted.\n    //\n    // Initially, we set the observe for this connection to null; this\n    // signifies to other code (which might run while we yield) that we\n    // are in the process of setting up an observe for this\n    // connection. Once the observe is ready to go, we replace null with\n    // the real observe handle (unless the placeholder has been deleted,\n    // signifying that the connection was closed already -- in this case\n    // we just clean up the observe that we started).\n    userObservesForConnections[connection.id] = null;\n    Meteor.defer(function () {\n      var foundMatchingUser;\n      // Because we upgrade unhashed login tokens to hashed tokens at\n      // login time, sessions will only be logged in with a hashed\n      // token. Thus we only need to observe hashed tokens here.\n      var observe = Meteor.users.find({\n        _id: userId,\n        'services.resume.loginTokens.hashedToken': newToken\n      }, { fields: { _id: 1 } }).observeChanges({\n        added: function () {\n          foundMatchingUser = true;\n        },\n        removed: function () {\n          connection.close();\n          // The onClose callback for the connection takes care of\n          // cleaning up the observe handle and any other state we have\n          // lying around.\n        }\n      });\n\n      // If the user ran another login or logout command we were waiting for\n      // the defer or added to fire, then we let the later one win (start an\n      // observe, etc) and just stop our observe now.\n      //\n      // Similarly, if the connection was already closed, then the onClose\n      // callback would have called removeTokenFromConnection and there won't be\n      // an entry in userObservesForConnections. We can stop the observe.\n      if (Accounts._getAccountData(connection.id, 'loginToken') !== newToken ||\n          !_.has(userObservesForConnections, connection.id)) {\n        observe.stop();\n        return;\n      }\n\n      if (userObservesForConnections[connection.id] !== null) {\n        throw new Error(\"Non-null user observe for connection \" +\n                        connection.id + \" while observe was being set up?\");\n      }\n\n      userObservesForConnections[connection.id] = observe;\n\n      if (! foundMatchingUser) {\n        // We've set up an observe on the user associated with `newToken`,\n        // so if the new token is removed from the database, we'll close\n        // the connection. But the token might have already been deleted\n        // before we set up the observe, which wouldn't have closed the\n        // connection because the observe wasn't running yet.\n        connection.close();\n      }\n    });\n  }\n};\n\n// Login handler for resume tokens.\nAccounts.registerLoginHandler(\"resume\", function(options) {\n  if (!options.resume)\n    return undefined;\n\n  check(options.resume, String);\n\n  var hashedToken = Accounts._hashLoginToken(options.resume);\n\n  // First look for just the new-style hashed login token, to avoid\n  // sending the unhashed token to the database in a query if we don't\n  // need to.\n  var user = Meteor.users.findOne(\n    {\"services.resume.loginTokens.hashedToken\": hashedToken});\n\n  if (! user) {\n    // If we didn't find the hashed login token, try also looking for\n    // the old-style unhashed token.  But we need to look for either\n    // the old-style token OR the new-style token, because another\n    // client connection logging in simultaneously might have already\n    // converted the token.\n    user = Meteor.users.findOne({\n      $or: [\n        {\"services.resume.loginTokens.hashedToken\": hashedToken},\n        {\"services.resume.loginTokens.token\": options.resume}\n      ]\n    });\n  }\n\n  if (! user)\n    return {\n      error: new Meteor.Error(403, \"You've been logged out by the server. Please log in again.\")\n    };\n\n  // Find the token, which will either be an object with fields\n  // {hashedToken, when} for a hashed token or {token, when} for an\n  // unhashed token.\n  var oldUnhashedStyleToken;\n  var token = _.find(user.services.resume.loginTokens, function (token) {\n    return token.hashedToken === hashedToken;\n  });\n  if (token) {\n    oldUnhashedStyleToken = false;\n  } else {\n    token = _.find(user.services.resume.loginTokens, function (token) {\n      return token.token === options.resume;\n    });\n    oldUnhashedStyleToken = true;\n  }\n\n  var tokenExpires = Accounts._tokenExpiration(token.when);\n  if (new Date() >= tokenExpires)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Your session has expired. Please log in again.\")\n    };\n\n  // Update to a hashed token when an unhashed token is encountered.\n  if (oldUnhashedStyleToken) {\n    // Only add the new hashed token if the old unhashed token still\n    // exists (this avoids resurrecting the token if it was deleted\n    // after we read it).  Using $addToSet avoids getting an index\n    // error if another client logging in simultaneously has already\n    // inserted the new hashed token.\n    Meteor.users.update(\n      {\n        _id: user._id,\n        \"services.resume.loginTokens.token\": options.resume\n      },\n      {$addToSet: {\n        \"services.resume.loginTokens\": {\n          \"hashedToken\": hashedToken,\n          \"when\": token.when\n        }\n      }}\n    );\n\n    // Remove the old token *after* adding the new, since otherwise\n    // another client trying to login between our removing the old and\n    // adding the new wouldn't find a token to login with.\n    Meteor.users.update(user._id, {\n      $pull: {\n        \"services.resume.loginTokens\": { \"token\": options.resume }\n      }\n    });\n  }\n\n  return {\n    userId: user._id,\n    stampedLoginToken: {\n      token: options.resume,\n      when: token.when\n    }\n  };\n});\n\n// (Also used by Meteor Accounts server and tests).\n//\nAccounts._generateStampedLoginToken = function () {\n  return {token: Random.secret(), when: (new Date)};\n};\n\n///\n/// TOKEN EXPIRATION\n///\n\nvar expireTokenInterval;\n\n// Deletes expired tokens from the database and closes all open connections\n// associated with these tokens.\n//\n// Exported for tests. Also, the arguments are only used by\n// tests. oldestValidDate is simulate expiring tokens without waiting\n// for them to actually expire. userId is used by tests to only expire\n// tokens for the test user.\nvar expireTokens = Accounts._expireTokens = function (oldestValidDate, userId) {\n  var tokenLifetimeMs = getTokenLifetimeMs();\n\n  // when calling from a test with extra arguments, you must specify both!\n  if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n    throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n  }\n\n  oldestValidDate = oldestValidDate ||\n    (new Date(new Date() - tokenLifetimeMs));\n  var userFilter = userId ? {_id: userId} : {};\n\n\n  // Backwards compatible with older versions of meteor that stored login token\n  // timestamps as numbers.\n  Meteor.users.update(_.extend(userFilter, {\n    $or: [\n      { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\n      { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\n    ]\n  }), {\n    $pull: {\n      \"services.resume.loginTokens\": {\n        $or: [\n          { when: { $lt: oldestValidDate } },\n          { when: { $lt: +oldestValidDate } }\n        ]\n      }\n    }\n  }, { multi: true });\n  // The observe on Meteor.users will take care of closing connections for\n  // expired tokens.\n};\n\nmaybeStopExpireTokensInterval = function () {\n  if (_.has(Accounts._options, \"loginExpirationInDays\") &&\n      Accounts._options.loginExpirationInDays === null &&\n      expireTokenInterval) {\n    Meteor.clearInterval(expireTokenInterval);\n    expireTokenInterval = null;\n  }\n};\n\nexpireTokenInterval = Meteor.setInterval(expireTokens,\n                                         EXPIRE_TOKENS_INTERVAL_MS);\n\n\n///\n/// OAuth Encryption Support\n///\n\nvar OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n\n\nvar usingOAuthEncryption = function () {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n};\n\n\n// OAuth service data is temporarily stored in the pending credentials\n// collection during the oauth authentication process.  Sensitive data\n// such as access tokens are encrypted without the user id because\n// we don't know the user id yet.  We re-encrypt these fields with the\n// user id included when storing the service data permanently in\n// the users collection.\n//\nvar pinEncryptedFieldsToUser = function (serviceData, userId) {\n  _.each(_.keys(serviceData), function (key) {\n    var value = serviceData[key];\n    if (OAuthEncryption && OAuthEncryption.isSealed(value))\n      value = OAuthEncryption.seal(OAuthEncryption.open(value), userId);\n    serviceData[key] = value;\n  });\n};\n\n\n// Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\nMeteor.startup(function () {\n  if (!usingOAuthEncryption())\n    return;\n\n  var ServiceConfiguration =\n    Package['service-configuration'].ServiceConfiguration;\n\n  ServiceConfiguration.configurations.find( {$and: [\n      { secret: {$exists: true} },\n      { \"secret.algorithm\": {$exists: false} }\n    ] } ).\n    forEach(function (config) {\n      ServiceConfiguration.configurations.update(\n        config._id,\n        { $set: {\n          secret: OAuthEncryption.seal(config.secret)\n        } }\n      );\n    });\n});\n\n\n///\n/// CREATE USER HOOKS\n///\n\nvar onCreateUserHook = null;\n\n/**\n * @summary Customize new user creation.\n * @locus Server\n * @param {Function} func Called whenever a new user is created. Return the new user object, or throw an `Error` to abort the creation.\n */\nAccounts.onCreateUser = function (func) {\n  if (onCreateUserHook)\n    throw new Error(\"Can only call onCreateUser once\");\n  else\n    onCreateUserHook = func;\n};\n\n// XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\nvar defaultCreateUserHook = function (options, user) {\n  if (options.profile)\n    user.profile = options.profile;\n  return user;\n};\n\n// Called by accounts-password\nAccounts.insertUserDoc = function (options, user) {\n  // - clone user document, to protect from modification\n  // - add createdAt timestamp\n  // - prepare an _id, so that you can modify other collections (eg\n  // create a first task for every new user)\n  //\n  // XXX If the onCreateUser or validateNewUser hooks fail, we might\n  // end up having modified some other collection\n  // inappropriately. The solution is probably to have onCreateUser\n  // accept two callbacks - one that gets called before inserting\n  // the user document (in which you can modify its contents), and\n  // one that gets called after (in which you should change other\n  // collections)\n  user = _.extend({createdAt: new Date(), _id: Random.id()}, user);\n\n  if (user.services)\n    _.each(user.services, function (serviceData) {\n      pinEncryptedFieldsToUser(serviceData, user._id);\n    });\n\n  var fullUser;\n  if (onCreateUserHook) {\n    fullUser = onCreateUserHook(options, user);\n\n    // This is *not* part of the API. We need this because we can't isolate\n    // the global server environment between tests, meaning we can't test\n    // both having a create user hook set and not having one set.\n    if (fullUser === 'TEST DEFAULT HOOK')\n      fullUser = defaultCreateUserHook(options, user);\n  } else {\n    fullUser = defaultCreateUserHook(options, user);\n  }\n\n  _.each(validateNewUserHooks, function (hook) {\n    if (!hook(fullUser))\n      throw new Meteor.Error(403, \"User validation failed\");\n  });\n\n  var userId;\n  try {\n    userId = Meteor.users.insert(fullUser);\n  } catch (e) {\n    // XXX string parsing sucks, maybe\n    // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n    if (e.name !== 'MongoError') throw e;\n    var match = e.err.match(/E11000 duplicate key error index: ([^ ]+)/);\n    if (!match) throw e;\n    if (match[1].indexOf('$emails.address') !== -1)\n      throw new Meteor.Error(403, \"Email already exists.\");\n    if (match[1].indexOf('username') !== -1)\n      throw new Meteor.Error(403, \"Username already exists.\");\n    // XXX better error reporting for services.facebook.id duplicate, etc\n    throw e;\n  }\n  return userId;\n};\n\nvar validateNewUserHooks = [];\n\n/**\n * @summary Set restrictions on new user creation.\n * @locus Server\n * @param {Function} func Called whenever a new user is created. Takes the new user object, and returns true to allow the creation or false to abort.\n */\nAccounts.validateNewUser = function (func) {\n  validateNewUserHooks.push(func);\n};\n\n// XXX Find a better place for this utility function\n// Like Perl's quotemeta: quotes all regexp metacharacters. See\n//   https://github.com/substack/quotemeta/blob/master/index.js\nvar quotemeta = function (str) {\n    return String(str).replace(/(\\W)/g, '\\\\$1');\n};\n\n// Helper function: returns false if email does not match company domain from\n// the configuration.\nvar testEmailDomain = function (email) {\n  var domain = Accounts._options.restrictCreationByEmailDomain;\n  return !domain ||\n    (_.isFunction(domain) && domain(email)) ||\n    (_.isString(domain) &&\n      (new RegExp('@' + quotemeta(domain) + '$', 'i')).test(email));\n};\n\n// Validate new user's email or Google/Facebook/GitHub account's email\nAccounts.validateNewUser(function (user) {\n  var domain = Accounts._options.restrictCreationByEmailDomain;\n  if (!domain)\n    return true;\n\n  var emailIsGood = false;\n  if (!_.isEmpty(user.emails)) {\n    emailIsGood = _.any(user.emails, function (email) {\n      return testEmailDomain(email.address);\n    });\n  } else if (!_.isEmpty(user.services)) {\n    // Find any email of any service and check it\n    emailIsGood = _.any(user.services, function (service) {\n      return service.email && testEmailDomain(service.email);\n    });\n  }\n\n  if (emailIsGood)\n    return true;\n\n  if (_.isString(domain))\n    throw new Meteor.Error(403, \"@\" + domain + \" email required\");\n  else\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\n});\n\n///\n/// MANAGING USER OBJECTS\n///\n\n// Updates or creates a user after we authenticate with a 3rd party.\n//\n// @param serviceName {String} Service name (eg, twitter).\n// @param serviceData {Object} Data to store in the user's record\n//        under services[serviceName]. Must include an \"id\" field\n//        which is a unique identifier for the user in the service.\n// @param options {Object, optional} Other options to pass to insertUserDoc\n//        (eg, profile)\n// @returns {Object} Object with token and id keys, like the result\n//        of the \"login\" method.\n//\nAccounts.updateOrCreateUserFromExternalService = function(\n  serviceName, serviceData, options) {\n  options = _.clone(options || {});\n\n  if (serviceName === \"password\" || serviceName === \"resume\")\n    throw new Error(\n      \"Can't use updateOrCreateUserFromExternalService with internal service \"\n        + serviceName);\n  if (!_.has(serviceData, 'id'))\n    throw new Error(\n      \"Service data for service \" + serviceName + \" must include id\");\n\n  // Look for a user with the appropriate service user id.\n  var selector = {};\n  var serviceIdKey = \"services.\" + serviceName + \".id\";\n\n  // XXX Temporary special case for Twitter. (Issue #629)\n  //   The serviceData.id will be a string representation of an integer.\n  //   We want it to match either a stored string or int representation.\n  //   This is to cater to earlier versions of Meteor storing twitter\n  //   user IDs in number form, and recent versions storing them as strings.\n  //   This can be removed once migration technology is in place, and twitter\n  //   users stored with integer IDs have been migrated to string IDs.\n  if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n    selector[\"$or\"] = [{},{}];\n    selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n    selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n  } else {\n    selector[serviceIdKey] = serviceData.id;\n  }\n\n  var user = Meteor.users.findOne(selector);\n\n  if (user) {\n    pinEncryptedFieldsToUser(serviceData, user._id);\n\n    // We *don't* process options (eg, profile) for update, but we do replace\n    // the serviceData (eg, so that we keep an unexpired access token and\n    // don't cache old email addresses in serviceData.email).\n    // XXX provide an onUpdateUser hook which would let apps update\n    //     the profile too\n    var setAttrs = {};\n    _.each(serviceData, function(value, key) {\n      setAttrs[\"services.\" + serviceName + \".\" + key] = value;\n    });\n\n    // XXX Maybe we should re-use the selector above and notice if the update\n    //     touches nothing?\n    Meteor.users.update(user._id, {$set: setAttrs});\n    return {\n      type: serviceName,\n      userId: user._id\n    };\n  } else {\n    // Create a new user with the service data. Pass other options through to\n    // insertUserDoc.\n    user = {services: {}};\n    user.services[serviceName] = serviceData;\n    return {\n      type: serviceName,\n      userId: Accounts.insertUserDoc(options, user)\n    };\n  }\n};\n\n\n///\n/// PUBLISHING DATA\n///\n\n// Publish the current user's record to the client.\nMeteor.publish(null, function() {\n  if (this.userId) {\n    return Meteor.users.find(\n      {_id: this.userId},\n      {fields: {profile: 1, username: 1, emails: 1}});\n  } else {\n    return null;\n  }\n}, /*suppress autopublish warning*/{is_auto: true});\n\n// If autopublish is on, publish these user fields. Login service\n// packages (eg accounts-google) add to these by calling\n// Accounts.addAutopublishFields Notably, this isn't implemented with\n// multiple publishes since DDP only merges only across top-level\n// fields, not subfields (such as 'services.facebook.accessToken')\nvar autopublishFields = {\n  loggedInUser: ['profile', 'username', 'emails'],\n  otherUsers: ['profile', 'username']\n};\n\n// Add to the list of fields or subfields to be automatically\n// published if autopublish is on. Must be called from top-level\n// code (ie, before Meteor.startup hooks run).\n//\n// @param opts {Object} with:\n//   - forLoggedInUser {Array} Array of fields published to the logged-in user\n//   - forOtherUsers {Array} Array of fields published to users that aren't logged in\nAccounts.addAutopublishFields = function(opts) {\n  autopublishFields.loggedInUser.push.apply(\n    autopublishFields.loggedInUser, opts.forLoggedInUser);\n  autopublishFields.otherUsers.push.apply(\n    autopublishFields.otherUsers, opts.forOtherUsers);\n};\n\nif (Package.autopublish) {\n  // Use Meteor.startup to give other packages a chance to call\n  // addAutopublishFields.\n  Meteor.startup(function () {\n    // ['profile', 'username'] -> {profile: 1, username: 1}\n    var toFieldSelector = function(fields) {\n      return _.object(_.map(fields, function(field) {\n        return [field, 1];\n      }));\n    };\n\n    Meteor.server.publish(null, function () {\n      if (this.userId) {\n        return Meteor.users.find(\n          {_id: this.userId},\n          {fields: toFieldSelector(autopublishFields.loggedInUser)});\n      } else {\n        return null;\n      }\n    }, /*suppress autopublish warning*/{is_auto: true});\n\n    // XXX this publish is neither dedup-able nor is it optimized by our special\n    // treatment of queries on a specific _id. Therefore this will have O(n^2)\n    // run-time performance every time a user document is changed (eg someone\n    // logging in). If this is a problem, we can instead write a manual publish\n    // function which filters out fields based on 'this.userId'.\n    Meteor.server.publish(null, function () {\n      var selector;\n      if (this.userId)\n        selector = {_id: {$ne: this.userId}};\n      else\n        selector = {};\n\n      return Meteor.users.find(\n        selector,\n        {fields: toFieldSelector(autopublishFields.otherUsers)});\n    }, /*suppress autopublish warning*/{is_auto: true});\n  });\n}\n\n// Publish all login service configuration fields other than secret.\nMeteor.publish(\"meteor.loginServiceConfiguration\", function () {\n  var ServiceConfiguration =\n    Package['service-configuration'].ServiceConfiguration;\n  return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\n}, {is_auto: true}); // not techincally autopublish, but stops the warning.\n\n// Allow a one-time configuration for a login service. Modifications\n// to this collection are also allowed in insecure mode.\nMeteor.methods({\n  \"configureLoginService\": function (options) {\n    check(options, Match.ObjectIncluding({service: String}));\n    // Don't let random users configure a service we haven't added yet (so\n    // that when we do later add it, it's set up with their configuration\n    // instead of ours).\n    // XXX if service configuration is oauth-specific then this code should\n    //     be in accounts-oauth; if it's not then the registry should be\n    //     in this package\n    if (!(Accounts.oauth\n          && _.contains(Accounts.oauth.serviceNames(), options.service))) {\n      throw new Meteor.Error(403, \"Service unknown\");\n    }\n\n    var ServiceConfiguration =\n      Package['service-configuration'].ServiceConfiguration;\n    if (ServiceConfiguration.configurations.findOne({service: options.service}))\n      throw new Meteor.Error(403, \"Service \" + options.service + \" already configured\");\n\n    if (_.has(options, \"secret\") && usingOAuthEncryption())\n      options.secret = OAuthEncryption.seal(options.secret);\n\n    ServiceConfiguration.configurations.insert(options);\n  }\n});\n\n\n///\n/// RESTRICTING WRITES TO USER OBJECTS\n///\n\nMeteor.users.allow({\n  // clients can modify the profile field of their own document, and\n  // nothing else.\n  update: function (userId, user, fields, modifier) {\n    // make sure it is our record\n    if (user._id !== userId)\n      return false;\n\n    // user can only modify the 'profile' field. sets to multiple\n    // sub-keys (eg profile.foo and profile.bar) are merged into entry\n    // in the fields list.\n    if (fields.length !== 1 || fields[0] !== 'profile')\n      return false;\n\n    return true;\n  },\n  fetch: ['_id'] // we only look at _id.\n});\n\n/// DEFAULT INDEXES ON USERS\nMeteor.users._ensureIndex('username', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('emails.address', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.resume.loginTokens.hashedToken',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.resume.loginTokens.token',\n                          {unique: 1, sparse: 1});\n// For taking care of logoutOtherClients calls that crashed before the tokens\n// were deleted.\nMeteor.users._ensureIndex('services.resume.haveLoginTokensToDelete',\n                          { sparse: 1 });\n// For expiring login tokens\nMeteor.users._ensureIndex(\"services.resume.loginTokens.when\", { sparse: 1 });\n\n///\n/// CLEAN UP FOR `logoutOtherClients`\n///\n\nvar deleteSavedTokens = function (userId, tokensToDelete) {\n  if (tokensToDelete) {\n    Meteor.users.update(userId, {\n      $unset: {\n        \"services.resume.haveLoginTokensToDelete\": 1,\n        \"services.resume.loginTokensToDelete\": 1\n      },\n      $pullAll: {\n        \"services.resume.loginTokens\": tokensToDelete\n      }\n    });\n  }\n};\n\nMeteor.startup(function () {\n  // If we find users who have saved tokens to delete on startup, delete them\n  // now. It's possible that the server could have crashed and come back up\n  // before new tokens are found in localStorage, but this shouldn't happen very\n  // often. We shouldn't put a delay here because that would give a lot of power\n  // to an attacker with a stolen login token and the ability to crash the\n  // server.\n  var users = Meteor.users.find({\n    \"services.resume.haveLoginTokensToDelete\": true\n  }, {\n    \"services.resume.loginTokensToDelete\": 1\n  });\n  users.forEach(function (user) {\n    deleteSavedTokens(user._id, user.services.resume.loginTokensToDelete);\n  });\n});\n","// XXX These should probably not actually be public?\n\nAccounts.urls = {};\n\nAccounts.urls.resetPassword = function (token) {\n  return Meteor.absoluteUrl('#/reset-password/' + token);\n};\n\nAccounts.urls.verifyEmail = function (token) {\n  return Meteor.absoluteUrl('#/verify-email/' + token);\n};\n\nAccounts.urls.enrollAccount = function (token) {\n  return Meteor.absoluteUrl('#/enroll-account/' + token);\n};\n"]}